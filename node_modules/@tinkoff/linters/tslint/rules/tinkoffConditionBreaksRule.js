"use strict";
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.Rule = void 0;
var Lint = require("tslint");
var tslint_1 = require("tslint");
var ts = require("typescript");
var INDENT = '    ';
var Rule = /** @class */ (function (_super) {
    __extends(Rule, _super);
    function Rule() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Rule.prototype.apply = function (sourceFile) {
        var walker = new ConditionalBreaksWalker(sourceFile, this.getOptions());
        return this.applyWithWalker(walker);
    };
    Rule.FAILURE_STRING = 'Expected new line between parts of ternary expression';
    Rule.WONT_FIX_FAILURE_STRING = Rule.FAILURE_STRING + " (cannot be auto-fixed because of nesting)";
    return Rule;
}(Lint.Rules.AbstractRule));
exports.Rule = Rule;
var ConditionalBreaksWalker = /** @class */ (function (_super) {
    __extends(ConditionalBreaksWalker, _super);
    function ConditionalBreaksWalker() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    ConditionalBreaksWalker.prototype.visitConditionalExpression = function (node) {
        this.checkForErrors(node);
        _super.prototype.visitConditionalExpression.call(this, node);
    };
    ConditionalBreaksWalker.prototype.checkForErrors = function (node) {
        if ((this.hasNoOperation(node) && this.isOnOneLine(node) && this.isNotTooLong(node)) ||
            this.bothPartsStartOnNewLine(node)) {
            return;
        }
        var start = node.getStart();
        var width = node.getWidth();
        if (this.isEmbeddedOrEmbedding(node)) {
            this.addFailureAt(start, width, Rule.WONT_FIX_FAILURE_STRING);
            return;
        }
        var fixes = ConditionalBreaksWalker.getFixes(node);
        this.addFailureAt(start, width, Rule.FAILURE_STRING, fixes);
    };
    ConditionalBreaksWalker.prototype.hasNoOperation = function (node) {
        return !(this.hasOperation(node.whenTrue) || this.hasOperation(node.whenFalse));
    };
    ConditionalBreaksWalker.prototype.isOnOneLine = function (node) {
        var whenTrueStartLine = this.getLineNumber(node.whenTrue.getFullStart());
        var whenFalseEndLine = this.getLineNumber(node.whenFalse.getEnd());
        return whenTrueStartLine === whenFalseEndLine;
    };
    ConditionalBreaksWalker.prototype.isNotTooLong = function (node) {
        return this.getBodyWidth(node) < this.getOptions()[0].maxWidth;
    };
    ConditionalBreaksWalker.prototype.bothPartsStartOnNewLine = function (node) {
        var whenTrueFirstChar = node.questionToken.getFullText().charCodeAt(0);
        var whenFalseFirstChar = node.colonToken.getFullText().charCodeAt(0);
        return ts.isLineBreak(whenTrueFirstChar) && ts.isLineBreak(whenFalseFirstChar);
    };
    ConditionalBreaksWalker.prototype.isEmbeddedOrEmbedding = function (node) {
        var parent = node.parent;
        while (parent) {
            if (parent.kind === ts.SyntaxKind.ConditionalExpression) {
                return true;
            }
            parent = parent.parent;
        }
        return node.getChildren().some(ConditionalBreaksWalker.checkChildren);
    };
    ConditionalBreaksWalker.prototype.getLineNumber = function (position) {
        return ts.getLineAndCharacterOfPosition(this.getSourceFile(), position).line;
    };
    ConditionalBreaksWalker.prototype.hasOperation = function (node) {
        return (ts.isBinaryExpression(node) ||
            node.getChildren().some(function (node) { return ts.isExpressionStatement(node); }));
    };
    ConditionalBreaksWalker.prototype.getBodyWidth = function (node) {
        return (node.whenTrue.getFullWidth() +
            node.colonToken.getFullWidth() +
            node.whenFalse.getFullWidth());
    };
    ConditionalBreaksWalker.checkChildren = function (node) {
        return (node.kind === ts.SyntaxKind.ConditionalExpression ||
            node.getChildren().some(ConditionalBreaksWalker.checkChildren));
    };
    ConditionalBreaksWalker.getFixes = function (node) {
        var lineAndChar = ts.getLineAndCharacterOfPosition(node.getSourceFile(), node.getStart());
        var lineStartPosition = ts.getPositionOfLineAndCharacter(node.getSourceFile(), lineAndChar.line, 0);
        var whitespaces = ConditionalBreaksWalker.getWhitespaces(node.getSourceFile().text, lineStartPosition);
        return [
            new tslint_1.Replacement(node.questionToken.getFullStart(), node.questionToken.getFullWidth(), node.questionToken.getFullText().replace(/\s*\?/, "\n" + whitespaces + "?")),
            new tslint_1.Replacement(node.colonToken.getFullStart(), node.colonToken.getFullWidth(), node.colonToken.getFullText().replace(/\s*:/, "\n" + whitespaces + ":")),
            new tslint_1.Replacement(node.whenTrue.getFullStart(), node.whenTrue.getFullWidth(), node.whenTrue.getFullText().replace(/^\s*/, ' ')),
            new tslint_1.Replacement(node.whenFalse.getFullStart(), node.whenFalse.getFullWidth(), node.whenFalse.getFullText().replace(/^\s*/, ' ')),
        ];
    };
    ConditionalBreaksWalker.getWhitespaces = function (text, startPosition) {
        var whitespaces = INDENT;
        var pos = startPosition;
        while (text[pos] === ' ' || text[pos] === '\t') {
            whitespaces += text[pos];
            pos++;
        }
        return whitespaces;
    };
    return ConditionalBreaksWalker;
}(Lint.RuleWalker));
